// <auto-generated />
#nullable enable

namespace SumUp;

using System;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using SumUp.Http;

public sealed partial class ReadersClient
{
    private readonly ApiClient _client;

    internal ReadersClient(ApiClient client)
    {
        _client = client;
    }

    /// <summary>
    /// Create a Reader
    /// </summary>
    /// <remarks>Create a new Reader for the merchant account.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Reader> Create(string merchantCode, ReadersCreateRequest body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<Reader>(stream, _client.SerializerOptions);
            return ApiResponse<Reader>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Create a Reader
    /// </summary>
    /// <remarks>Create a new Reader for the merchant account.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Reader>> CreateAsync(string merchantCode, ReadersCreateRequest body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<Reader>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<Reader>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Create a Reader Checkout
    /// </summary>
    /// <remarks>Creates a Checkout for a Reader. This process is asynchronous and the actual transaction may take some time to be stared on the device. There are some caveats when using this endpoint: * The target device must be online, otherwise checkout won't be accepted * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During this time, any other checkout for the same device will be rejected. **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="body">A checkout initial attributes</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<CreateReaderCheckoutResponse> CreateCheckout(string merchantCode, string readerId, CreateReaderCheckoutRequest body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/checkout", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 422:
                    {
                        var errorForStatus422 = _client.TryDeserialize<CreateReaderCheckoutUnprocessableEntity>(responseBody);
                        throw new ApiException<CreateReaderCheckoutUnprocessableEntity>(response.StatusCode, errorForStatus422, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 502:
                    {
                        var errorForStatus502 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus502, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 504:
                    {
                        var errorForStatus504 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus504, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<CreateReaderCheckoutResponse>(stream, _client.SerializerOptions);
            return ApiResponse<CreateReaderCheckoutResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Create a Reader Checkout
    /// </summary>
    /// <remarks>Creates a Checkout for a Reader. This process is asynchronous and the actual transaction may take some time to be stared on the device. There are some caveats when using this endpoint: * The target device must be online, otherwise checkout won't be accepted * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During this time, any other checkout for the same device will be rejected. **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="body">A checkout initial attributes</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<CreateReaderCheckoutResponse>> CreateCheckoutAsync(string merchantCode, string readerId, CreateReaderCheckoutRequest body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/checkout", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 422:
                    {
                        var errorForStatus422 = _client.TryDeserialize<CreateReaderCheckoutUnprocessableEntity>(responseBody);
                        throw new ApiException<CreateReaderCheckoutUnprocessableEntity>(response.StatusCode, errorForStatus422, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 502:
                    {
                        var errorForStatus502 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus502, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 504:
                    {
                        var errorForStatus504 = _client.TryDeserialize<CreateReaderCheckoutError>(responseBody);
                        throw new ApiException<CreateReaderCheckoutError>(response.StatusCode, errorForStatus504, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<CreateReaderCheckoutResponse>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<CreateReaderCheckoutResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Delete a reader
    /// </summary>
    /// <remarks>Delete a reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<JsonDocument> Delete(string merchantCode, string id, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Delete, "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            return ApiResponse<JsonDocument>.From(default, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Delete a reader
    /// </summary>
    /// <remarks>Delete a reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<JsonDocument>> DeleteAsync(string merchantCode, string id, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Delete, "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            return ApiResponse<JsonDocument>.From(default, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a Reader
    /// </summary>
    /// <remarks>Retrieve a Reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="ifModifiedSince">Return the reader only if it has been modified after the specified timestamp given in the headers. Timestamps are accepted in the following formats: - HTTP Standard: [IMF format (RFC 5322)](https://www.rfc-editor.org/rfc/rfc5322#section-3.3), sometimes also referred to as [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1). - RFC 3339: Used for timestamps in JSON payloads on this API.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Reader> Get(string merchantCode, string id, string? ifModifiedSince = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
            builder.AddHeader("If-Modified-Since", ifModifiedSince);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<Reader>(stream, _client.SerializerOptions);
            return ApiResponse<Reader>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a Reader
    /// </summary>
    /// <remarks>Retrieve a Reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="ifModifiedSince">Return the reader only if it has been modified after the specified timestamp given in the headers. Timestamps are accepted in the following formats: - HTTP Standard: [IMF format (RFC 5322)](https://www.rfc-editor.org/rfc/rfc5322#section-3.3), sometimes also referred to as [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1). - RFC 3339: Used for timestamps in JSON payloads on this API.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Reader>> GetAsync(string merchantCode, string id, string? ifModifiedSince = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
            builder.AddHeader("If-Modified-Since", ifModifiedSince);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<Reader>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<Reader>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Get a Reader Status
    /// </summary>
    /// <remarks>Provides the last known status for a Reader. This endpoint allows you to retrieve updates from the connected card reader, including the current screen being displayed during the payment process and the device status (battery level, connectivity, and update state). Supported States * `IDLE` – Reader ready for next transaction * `SELECTING_TIP` – Waiting for tip input * `WAITING_FOR_CARD` – Awaiting card insert/tap * `WAITING_FOR_PIN` – Waiting for PIN entry * `WAITING_FOR_SIGNATURE` – Waiting for customer signature * `UPDATING_FIRMWARE` – Firmware update in progress Device Status * `ONLINE` – Device connected and operational * `OFFLINE` – Device disconnected (last state persisted) **Note**: If the target device is a Solo, it must be in version 3.3.39.0 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="accept">Request parameter.</param>
    /// <param name="contentType">Request parameter.</param>
    /// <param name="authorization">Request parameter.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<StatusResponse> GetStatus(string merchantCode, string readerId, string accept, string contentType, string authorization, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/status", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
            builder.AddHeader("Accept", accept);
            builder.AddHeader("Content-Type", contentType);
            builder.AddHeader("Authorization", authorization);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<BadRequest>(responseBody);
                        throw new ApiException<BadRequest>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Unauthorized>(responseBody);
                        throw new ApiException<Unauthorized>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<NotFound>(responseBody);
                        throw new ApiException<NotFound>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<InternalServerError>(responseBody);
                        throw new ApiException<InternalServerError>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 502:
                    {
                        var errorForStatus502 = _client.TryDeserialize<BadGateway>(responseBody);
                        throw new ApiException<BadGateway>(response.StatusCode, errorForStatus502, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 504:
                    {
                        var errorForStatus504 = _client.TryDeserialize<GatewayTimeout>(responseBody);
                        throw new ApiException<GatewayTimeout>(response.StatusCode, errorForStatus504, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<StatusResponse>(stream, _client.SerializerOptions);
            return ApiResponse<StatusResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Get a Reader Status
    /// </summary>
    /// <remarks>Provides the last known status for a Reader. This endpoint allows you to retrieve updates from the connected card reader, including the current screen being displayed during the payment process and the device status (battery level, connectivity, and update state). Supported States * `IDLE` – Reader ready for next transaction * `SELECTING_TIP` – Waiting for tip input * `WAITING_FOR_CARD` – Awaiting card insert/tap * `WAITING_FOR_PIN` – Waiting for PIN entry * `WAITING_FOR_SIGNATURE` – Waiting for customer signature * `UPDATING_FIRMWARE` – Firmware update in progress Device Status * `ONLINE` – Device connected and operational * `OFFLINE` – Device disconnected (last state persisted) **Note**: If the target device is a Solo, it must be in version 3.3.39.0 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="accept">Request parameter.</param>
    /// <param name="contentType">Request parameter.</param>
    /// <param name="authorization">Request parameter.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<StatusResponse>> GetStatusAsync(string merchantCode, string readerId, string accept, string contentType, string authorization, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/status", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
            builder.AddHeader("Accept", accept);
            builder.AddHeader("Content-Type", contentType);
            builder.AddHeader("Authorization", authorization);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<BadRequest>(responseBody);
                        throw new ApiException<BadRequest>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Unauthorized>(responseBody);
                        throw new ApiException<Unauthorized>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<NotFound>(responseBody);
                        throw new ApiException<NotFound>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<InternalServerError>(responseBody);
                        throw new ApiException<InternalServerError>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 502:
                    {
                        var errorForStatus502 = _client.TryDeserialize<BadGateway>(responseBody);
                        throw new ApiException<BadGateway>(response.StatusCode, errorForStatus502, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 504:
                    {
                        var errorForStatus504 = _client.TryDeserialize<GatewayTimeout>(responseBody);
                        throw new ApiException<GatewayTimeout>(response.StatusCode, errorForStatus504, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<StatusResponse>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<StatusResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List Readers
    /// </summary>
    /// <remarks>List all readers of the merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<ReadersListResponse> List(string merchantCode, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var jsonStream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var document = JsonDocument.Parse(jsonStream);
            return ApiResponse<ReadersListResponse>.From((ReadersListResponse)(object)document, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List Readers
    /// </summary>
    /// <remarks>List all readers of the merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<ReadersListResponse>> ListAsync(string merchantCode, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var jsonStream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var document = await JsonDocument.ParseAsync(jsonStream, cancellationToken: effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<ReadersListResponse>.From((ReadersListResponse)(object)document, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Terminate a Reader Checkout
    /// </summary>
    /// <remarks>Terminate a Reader Checkout stops the current transaction on the target device. This process is asynchronous and the actual termination may take some time to be performed on the device. There are some caveats when using this endpoint: * The target device must be online, otherwise terminate won't be accepted * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting for PIN, etc. * There is no confirmation of the termination. If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status will be sent as `failed` to the provided URL. **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<JsonDocument> TerminateCheckout(string merchantCode, string readerId, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/terminate", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 422:
                    {
                        var errorForStatus422 = _client.TryDeserialize<CreateReaderTerminateUnprocessableEntity>(responseBody);
                        throw new ApiException<CreateReaderTerminateUnprocessableEntity>(response.StatusCode, errorForStatus422, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 502:
                    {
                        var errorForStatus502 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus502, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 504:
                    {
                        var errorForStatus504 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus504, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<JsonDocument>(stream, _client.SerializerOptions);
            return ApiResponse<JsonDocument>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Terminate a Reader Checkout
    /// </summary>
    /// <remarks>Terminate a Reader Checkout stops the current transaction on the target device. This process is asynchronous and the actual termination may take some time to be performed on the device. There are some caveats when using this endpoint: * The target device must be online, otherwise terminate won't be accepted * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting for PIN, etc. * There is no confirmation of the termination. If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status will be sent as `failed` to the provided URL. **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<JsonDocument>> TerminateCheckoutAsync(string merchantCode, string readerId, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/terminate", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 422:
                    {
                        var errorForStatus422 = _client.TryDeserialize<CreateReaderTerminateUnprocessableEntity>(responseBody);
                        throw new ApiException<CreateReaderTerminateUnprocessableEntity>(response.StatusCode, errorForStatus422, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 502:
                    {
                        var errorForStatus502 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus502, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 504:
                    {
                        var errorForStatus504 = _client.TryDeserialize<CreateReaderTerminateError>(responseBody);
                        throw new ApiException<CreateReaderTerminateError>(response.StatusCode, errorForStatus504, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<JsonDocument>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<JsonDocument>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Update a Reader
    /// </summary>
    /// <remarks>Update a Reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Reader> Update(string merchantCode, string id, ReadersUpdateRequest body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(new HttpMethod("PATCH"), "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 403:
                    {
                        var errorForStatus403 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus403, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<Reader>(stream, _client.SerializerOptions);
            return ApiResponse<Reader>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Update a Reader
    /// </summary>
    /// <remarks>Update a Reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Reader>> UpdateAsync(string merchantCode, string id, ReadersUpdateRequest body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(new HttpMethod("PATCH"), "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 403:
                    {
                        var errorForStatus403 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus403, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Problem>(responseBody);
                        throw new ApiException<Problem>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<Reader>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<Reader>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }
}