// <auto-generated />
#nullable enable

namespace SumUp;

using System;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using SumUp.Http;

public sealed partial class ReadersClient
{
    private readonly ApiClient _client;

    internal ReadersClient(ApiClient client)
    {
        _client = client;
    }

    /// <summary>
    /// Create a Reader
    /// </summary>
    /// <remarks>Create a new Reader for the merchant account.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Reader> Create(string merchantCode, ReadersCreateRequest body, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
        });
        return _client.Send<Reader>(request, body, "application/json", cancellationToken);
    }

    /// <summary>
    /// Create a Reader
    /// </summary>
    /// <remarks>Create a new Reader for the merchant account.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Reader>> CreateAsync(string merchantCode, ReadersCreateRequest body, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
        });
        return await _client.SendAsync<Reader>(request, body, "application/json", cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Create a Reader Checkout
    /// </summary>
    /// <remarks>Creates a Checkout for a Reader. This process is asynchronous and the actual transaction may take some time to be stared on the device. There are some caveats when using this endpoint: * The target device must be online, otherwise checkout won't be accepted * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During this time, any other checkout for the same device will be rejected. **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="body">A checkout initial attributes</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<CreateReaderCheckoutResponse> CreateCheckout(string merchantCode, string readerId, CreateReaderCheckoutRequest body, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/checkout", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
        });
        return _client.Send<CreateReaderCheckoutResponse>(request, body, "application/json", cancellationToken);
    }

    /// <summary>
    /// Create a Reader Checkout
    /// </summary>
    /// <remarks>Creates a Checkout for a Reader. This process is asynchronous and the actual transaction may take some time to be stared on the device. There are some caveats when using this endpoint: * The target device must be online, otherwise checkout won't be accepted * After the checkout is accepted, the system has 60 seconds to start the payment on the target device. During this time, any other checkout for the same device will be rejected. **Note**: If the target device is a Solo, it must be in version 3.3.24.3 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="body">A checkout initial attributes</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<CreateReaderCheckoutResponse>> CreateCheckoutAsync(string merchantCode, string readerId, CreateReaderCheckoutRequest body, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/checkout", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
        });
        return await _client.SendAsync<CreateReaderCheckoutResponse>(request, body, "application/json", cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Delete a reader
    /// </summary>
    /// <remarks>Delete a reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<JsonDocument> Delete(string merchantCode, string id, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Delete, "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
        });
        return _client.Send<JsonDocument>(request, null, null, cancellationToken);
    }

    /// <summary>
    /// Delete a reader
    /// </summary>
    /// <remarks>Delete a reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<JsonDocument>> DeleteAsync(string merchantCode, string id, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Delete, "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
        });
        return await _client.SendAsync<JsonDocument>(request, null, null, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Retrieve a Reader
    /// </summary>
    /// <remarks>Retrieve a Reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="ifModifiedSince">Return the reader only if it has been modified after the specified timestamp given in the headers. Timestamps are accepted in the following formats: - HTTP Standard: [IMF format (RFC 5322)](https://www.rfc-editor.org/rfc/rfc5322#section-3.3), sometimes also referred to as [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1). - RFC 3339: Used for timestamps in JSON payloads on this API.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Reader> Get(string merchantCode, string id, string? ifModifiedSince = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
            builder.AddHeader("If-Modified-Since", ifModifiedSince);
        });
        return _client.Send<Reader>(request, null, null, cancellationToken);
    }

    /// <summary>
    /// Retrieve a Reader
    /// </summary>
    /// <remarks>Retrieve a Reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="ifModifiedSince">Return the reader only if it has been modified after the specified timestamp given in the headers. Timestamps are accepted in the following formats: - HTTP Standard: [IMF format (RFC 5322)](https://www.rfc-editor.org/rfc/rfc5322#section-3.3), sometimes also referred to as [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1). - RFC 3339: Used for timestamps in JSON payloads on this API.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Reader>> GetAsync(string merchantCode, string id, string? ifModifiedSince = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
            builder.AddHeader("If-Modified-Since", ifModifiedSince);
        });
        return await _client.SendAsync<Reader>(request, null, null, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Get a Reader Status
    /// </summary>
    /// <remarks>Provides the last known status for a Reader. This endpoint allows you to retrieve updates from the connected card reader, including the current screen being displayed during the payment process and the device status (battery level, connectivity, and update state). Supported States * `IDLE` – Reader ready for next transaction * `SELECTING_TIP` – Waiting for tip input * `WAITING_FOR_CARD` – Awaiting card insert/tap * `WAITING_FOR_PIN` – Waiting for PIN entry * `WAITING_FOR_SIGNATURE` – Waiting for customer signature * `UPDATING_FIRMWARE` – Firmware update in progress Device Status * `ONLINE` – Device connected and operational * `OFFLINE` – Device disconnected (last state persisted) **Note**: If the target device is a Solo, it must be in version 3.3.39.0 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="accept">Request parameter.</param>
    /// <param name="contentType">Request parameter.</param>
    /// <param name="authorization">Request parameter.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<StatusResponse> GetStatus(string merchantCode, string readerId, string accept, string contentType, string authorization, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/status", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
            builder.AddHeader("Accept", accept);
            builder.AddHeader("Content-Type", contentType);
            builder.AddHeader("Authorization", authorization);
        });
        return _client.Send<StatusResponse>(request, null, null, cancellationToken);
    }

    /// <summary>
    /// Get a Reader Status
    /// </summary>
    /// <remarks>Provides the last known status for a Reader. This endpoint allows you to retrieve updates from the connected card reader, including the current screen being displayed during the payment process and the device status (battery level, connectivity, and update state). Supported States * `IDLE` – Reader ready for next transaction * `SELECTING_TIP` – Waiting for tip input * `WAITING_FOR_CARD` – Awaiting card insert/tap * `WAITING_FOR_PIN` – Waiting for PIN entry * `WAITING_FOR_SIGNATURE` – Waiting for customer signature * `UPDATING_FIRMWARE` – Firmware update in progress Device Status * `ONLINE` – Device connected and operational * `OFFLINE` – Device disconnected (last state persisted) **Note**: If the target device is a Solo, it must be in version 3.3.39.0 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="accept">Request parameter.</param>
    /// <param name="contentType">Request parameter.</param>
    /// <param name="authorization">Request parameter.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<StatusResponse>> GetStatusAsync(string merchantCode, string readerId, string accept, string contentType, string authorization, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/status", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
            builder.AddHeader("Accept", accept);
            builder.AddHeader("Content-Type", contentType);
            builder.AddHeader("Authorization", authorization);
        });
        return await _client.SendAsync<StatusResponse>(request, null, null, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// List Readers
    /// </summary>
    /// <remarks>List all readers of the merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<ReadersListResponse> List(string merchantCode, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
        });
        return _client.Send<ReadersListResponse>(request, null, null, cancellationToken);
    }

    /// <summary>
    /// List Readers
    /// </summary>
    /// <remarks>List all readers of the merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<ReadersListResponse>> ListAsync(string merchantCode, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/readers", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
        });
        return await _client.SendAsync<ReadersListResponse>(request, null, null, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Terminate a Reader Checkout
    /// </summary>
    /// <remarks>Terminate a Reader Checkout stops the current transaction on the target device. This process is asynchronous and the actual termination may take some time to be performed on the device. There are some caveats when using this endpoint: * The target device must be online, otherwise terminate won't be accepted * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting for PIN, etc. * There is no confirmation of the termination. If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status will be sent as `failed` to the provided URL. **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<JsonDocument> TerminateCheckout(string merchantCode, string readerId, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/terminate", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
        });
        return _client.Send<JsonDocument>(request, null, null, cancellationToken);
    }

    /// <summary>
    /// Terminate a Reader Checkout
    /// </summary>
    /// <remarks>Terminate a Reader Checkout stops the current transaction on the target device. This process is asynchronous and the actual termination may take some time to be performed on the device. There are some caveats when using this endpoint: * The target device must be online, otherwise terminate won't be accepted * The action will succeed only if the device is waiting for cardholder action: e.g: waiting for card, waiting for PIN, etc. * There is no confirmation of the termination. If a transaction is successfully terminated and `return_url` was provided on Checkout, the transaction status will be sent as `failed` to the provided URL. **Note**: If the target device is a Solo, it must be in version 3.3.28.0 or higher.</remarks>
    /// <param name="merchantCode">Merchant Code</param>
    /// <param name="readerId">The unique identifier of the Reader</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<JsonDocument>> TerminateCheckoutAsync(string merchantCode, string readerId, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/merchants/{merchant_code}/readers/{reader_id}/terminate", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("reader_id", readerId);
        });
        return await _client.SendAsync<JsonDocument>(request, null, null, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Update a Reader
    /// </summary>
    /// <remarks>Update a Reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Reader> Update(string merchantCode, string id, ReadersUpdateRequest body, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(new HttpMethod("PATCH"), "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
        });
        return _client.Send<Reader>(request, body, "application/json", cancellationToken);
    }

    /// <summary>
    /// Update a Reader
    /// </summary>
    /// <remarks>Update a Reader.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="id">The unique identifier of the reader.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Reader>> UpdateAsync(string merchantCode, string id, ReadersUpdateRequest body, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(new HttpMethod("PATCH"), "/v0.1/merchants/{merchant_code}/readers/{id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("id", id);
        });
        return await _client.SendAsync<Reader>(request, body, "application/json", cancellationToken).ConfigureAwait(false);
    }
}