// <auto-generated />
#nullable enable

namespace SumUp;

using System;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using SumUp.Http;

public sealed partial class MerchantsClient
{
    private readonly ApiClient _client;

    internal MerchantsClient(ApiClient client)
    {
        _client = client;
    }

    /// <summary>
    /// Retrieve a Merchant
    /// </summary>
    /// <remarks>Retrieve a merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="version">The version of the resource. At the moment, the only supported value is `latest`. When provided and the requested resource's `change_status` is pending, the resource will be returned with all pending changes applied. When no changes are pending the resource is returned as is. The `change_status` in the response body will reflect the current state of the resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Merchant> Get(string merchantCode, string? version = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v1/merchants/{merchant_code}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("version", version);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<MerchantsGetError404>(responseBody);
                        throw new ApiException<MerchantsGetError404>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<Merchant>(stream, _client.SerializerOptions);
            return ApiResponse<Merchant>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a Merchant
    /// </summary>
    /// <remarks>Retrieve a merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="version">The version of the resource. At the moment, the only supported value is `latest`. When provided and the requested resource's `change_status` is pending, the resource will be returned with all pending changes applied. When no changes are pending the resource is returned as is. The `change_status` in the response body will reflect the current state of the resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Merchant>> GetAsync(string merchantCode, string? version = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v1/merchants/{merchant_code}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("version", version);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<MerchantsGetError404>(responseBody);
                        throw new ApiException<MerchantsGetError404>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<Merchant>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<Merchant>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a Person
    /// </summary>
    /// <remarks>Returns a single person related to the merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="personId">Person ID</param>
    /// <param name="version">The version of the resource. At the moment, the only supported value is `latest`. When provided and the requested resource's `change_status` is pending, the resource will be returned with all pending changes applied. When no changes are pending the resource is returned as is. The `change_status` in the response body will reflect the current state of the resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Person> GetPerson(string merchantCode, string personId, string? version = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v1/merchants/{merchant_code}/persons/{person_id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("person_id", personId);
            builder.AddQuery("version", version);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<MerchantsGetPersonError404>(responseBody);
                        throw new ApiException<MerchantsGetPersonError404>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<MerchantsGetPersonError500>(responseBody);
                        throw new ApiException<MerchantsGetPersonError500>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<Person>(stream, _client.SerializerOptions);
            return ApiResponse<Person>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a Person
    /// </summary>
    /// <remarks>Returns a single person related to the merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="personId">Person ID</param>
    /// <param name="version">The version of the resource. At the moment, the only supported value is `latest`. When provided and the requested resource's `change_status` is pending, the resource will be returned with all pending changes applied. When no changes are pending the resource is returned as is. The `change_status` in the response body will reflect the current state of the resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Person>> GetPersonAsync(string merchantCode, string personId, string? version = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v1/merchants/{merchant_code}/persons/{person_id}", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddPath("person_id", personId);
            builder.AddQuery("version", version);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<MerchantsGetPersonError404>(responseBody);
                        throw new ApiException<MerchantsGetPersonError404>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<MerchantsGetPersonError500>(responseBody);
                        throw new ApiException<MerchantsGetPersonError500>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<Person>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<Person>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List Persons
    /// </summary>
    /// <remarks>Returns a list of persons related to the merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="version">The version of the resource. At the moment, the only supported value is `latest`. When provided and the requested resource's `change_status` is pending, the resource will be returned with all pending changes applied. When no changes are pending the resource is returned as is. The `change_status` in the response body will reflect the current state of the resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<ListPersonsResponseBody> ListPersons(string merchantCode, string? version = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v1/merchants/{merchant_code}/persons", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("version", version);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<MerchantsListPersonsError404>(responseBody);
                        throw new ApiException<MerchantsListPersonsError404>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<MerchantsListPersonsError500>(responseBody);
                        throw new ApiException<MerchantsListPersonsError500>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<ListPersonsResponseBody>(stream, _client.SerializerOptions);
            return ApiResponse<ListPersonsResponseBody>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List Persons
    /// </summary>
    /// <remarks>Returns a list of persons related to the merchant.</remarks>
    /// <param name="merchantCode">Short unique identifier for the merchant.</param>
    /// <param name="version">The version of the resource. At the moment, the only supported value is `latest`. When provided and the requested resource's `change_status` is pending, the resource will be returned with all pending changes applied. When no changes are pending the resource is returned as is. The `change_status` in the response body will reflect the current state of the resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<ListPersonsResponseBody>> ListPersonsAsync(string merchantCode, string? version = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v1/merchants/{merchant_code}/persons", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("version", version);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<MerchantsListPersonsError404>(responseBody);
                        throw new ApiException<MerchantsListPersonsError404>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 500:
                    {
                        var errorForStatus500 = _client.TryDeserialize<MerchantsListPersonsError500>(responseBody);
                        throw new ApiException<MerchantsListPersonsError500>(response.StatusCode, errorForStatus500, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<ListPersonsResponseBody>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<ListPersonsResponseBody>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }
}