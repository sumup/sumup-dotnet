// <auto-generated />
#nullable enable

namespace SumUp;

using System;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using SumUp.Http;

public sealed partial class CheckoutsClient
{
    private readonly ApiClient _client;

    internal CheckoutsClient(ApiClient client)
    {
        _client = client;
    }

    /// <summary>
    /// Create a checkout
    /// </summary>
    /// <remarks>Creates a new payment checkout resource. The unique `checkout_reference` created by this request, is used for further manipulation of the checkout. For 3DS checkouts, add the `redirect_url` parameter to your request body schema. Follow by processing a checkout to charge the provided payment instrument.</remarks>
    /// <param name="body">Request body payload.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Checkout> Create(CheckoutCreateRequest body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/checkouts");
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<ErrorExtended>(responseBody);
                        throw new ApiException<ErrorExtended>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 403:
                    {
                        var errorForStatus403 = _client.TryDeserialize<ErrorForbidden>(responseBody);
                        throw new ApiException<ErrorForbidden>(response.StatusCode, errorForStatus403, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<Checkout>(stream, _client.SerializerOptions);
            return ApiResponse<Checkout>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Create a checkout
    /// </summary>
    /// <remarks>Creates a new payment checkout resource. The unique `checkout_reference` created by this request, is used for further manipulation of the checkout. For 3DS checkouts, add the `redirect_url` parameter to your request body schema. Follow by processing a checkout to charge the provided payment instrument.</remarks>
    /// <param name="body">Request body payload.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Checkout>> CreateAsync(CheckoutCreateRequest body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/checkouts");
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<ErrorExtended>(responseBody);
                        throw new ApiException<ErrorExtended>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 403:
                    {
                        var errorForStatus403 = _client.TryDeserialize<ErrorForbidden>(responseBody);
                        throw new ApiException<ErrorForbidden>(response.StatusCode, errorForStatus403, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<Checkout>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<Checkout>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Deactivate a checkout
    /// </summary>
    /// <remarks>Deactivates an identified checkout resource. If the checkout has already been processed it can not be deactivated.</remarks>
    /// <param name="id">Unique ID of the checkout resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<Checkout> Deactivate(string id, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Delete, "/v0.1/checkouts/{id}", builder =>
        {
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<Checkout>(stream, _client.SerializerOptions);
            return ApiResponse<Checkout>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Deactivate a checkout
    /// </summary>
    /// <remarks>Deactivates an identified checkout resource. If the checkout has already been processed it can not be deactivated.</remarks>
    /// <param name="id">Unique ID of the checkout resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<Checkout>> DeactivateAsync(string id, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Delete, "/v0.1/checkouts/{id}", builder =>
        {
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<Checkout>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<Checkout>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a checkout
    /// </summary>
    /// <remarks>Retrieves an identified checkout resource. Use this request after processing a checkout to confirm its status and inform the end user respectively.</remarks>
    /// <param name="id">Unique ID of the checkout resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<CheckoutSuccess> Get(string id, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/checkouts/{id}", builder =>
        {
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<CheckoutSuccess>(stream, _client.SerializerOptions);
            return ApiResponse<CheckoutSuccess>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a checkout
    /// </summary>
    /// <remarks>Retrieves an identified checkout resource. Use this request after processing a checkout to confirm its status and inform the end user respectively.</remarks>
    /// <param name="id">Unique ID of the checkout resource.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<CheckoutSuccess>> GetAsync(string id, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/checkouts/{id}", builder =>
        {
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<CheckoutSuccess>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<CheckoutSuccess>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List checkouts
    /// </summary>
    /// <remarks>Lists created checkout resources according to the applied `checkout_reference`.</remarks>
    /// <param name="checkoutReference">Filters the list of checkout resources by the unique ID of the checkout.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<IEnumerable<CheckoutSuccess>> List(string? checkoutReference = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/checkouts", builder =>
        {
            builder.AddQuery("checkout_reference", checkoutReference);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<IEnumerable<CheckoutSuccess>>(stream, _client.SerializerOptions);
            return ApiResponse<IEnumerable<CheckoutSuccess>>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List checkouts
    /// </summary>
    /// <remarks>Lists created checkout resources according to the applied `checkout_reference`.</remarks>
    /// <param name="checkoutReference">Filters the list of checkout resources by the unique ID of the checkout.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<IEnumerable<CheckoutSuccess>>> ListAsync(string? checkoutReference = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/checkouts", builder =>
        {
            builder.AddQuery("checkout_reference", checkoutReference);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<IEnumerable<CheckoutSuccess>>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<IEnumerable<CheckoutSuccess>>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Get available payment methods
    /// </summary>
    /// <remarks>Get payment methods available for the given merchant to use with a checkout.</remarks>
    /// <param name="merchantCode">The SumUp merchant code.</param>
    /// <param name="amount">The amount for which the payment methods should be eligible, in major units. Note that currency must also be provided when filtering by amount.</param>
    /// <param name="currency">The currency for which the payment methods should be eligible.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<CheckoutsListAvailablePaymentMethodsResponse> ListAvailablePaymentMethods(string merchantCode, decimal? amount = null, string? currency = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/payment-methods", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("amount", amount);
            builder.AddQuery("currency", currency);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<DetailsError>(responseBody);
                        throw new ApiException<DetailsError>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<CheckoutsListAvailablePaymentMethodsResponse>(stream, _client.SerializerOptions);
            return ApiResponse<CheckoutsListAvailablePaymentMethodsResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Get available payment methods
    /// </summary>
    /// <remarks>Get payment methods available for the given merchant to use with a checkout.</remarks>
    /// <param name="merchantCode">The SumUp merchant code.</param>
    /// <param name="amount">The amount for which the payment methods should be eligible, in major units. Note that currency must also be provided when filtering by amount.</param>
    /// <param name="currency">The currency for which the payment methods should be eligible.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<CheckoutsListAvailablePaymentMethodsResponse>> ListAvailablePaymentMethodsAsync(string merchantCode, decimal? amount = null, string? currency = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/merchants/{merchant_code}/payment-methods", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("amount", amount);
            builder.AddQuery("currency", currency);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<DetailsError>(responseBody);
                        throw new ApiException<DetailsError>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<CheckoutsListAvailablePaymentMethodsResponse>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<CheckoutsListAvailablePaymentMethodsResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Process a checkout
    /// </summary>
    /// <remarks>Processing a checkout will attempt to charge the provided payment instrument for the amount of the specified checkout resource initiated in the `Create a checkout` endpoint. Follow this request with `Retrieve a checkout` to confirm its status.</remarks>
    /// <param name="id">Unique ID of the checkout resource.</param>
    /// <param name="body">Details of the payment instrument for processing the checkout.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<CheckoutSuccess> Process(string id, ProcessCheckout body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Put, "/v0.1/checkouts/{id}", builder =>
        {
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<JsonDocument>(responseBody);
                        throw new ApiException<JsonDocument>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<CheckoutSuccess>(stream, _client.SerializerOptions);
            return ApiResponse<CheckoutSuccess>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Process a checkout
    /// </summary>
    /// <remarks>Processing a checkout will attempt to charge the provided payment instrument for the amount of the specified checkout resource initiated in the `Create a checkout` endpoint. Follow this request with `Retrieve a checkout` to confirm its status.</remarks>
    /// <param name="id">Unique ID of the checkout resource.</param>
    /// <param name="body">Details of the payment instrument for processing the checkout.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<CheckoutSuccess>> ProcessAsync(string id, ProcessCheckout body, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Put, "/v0.1/checkouts/{id}", builder =>
        {
            builder.AddPath("id", id);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 400:
                    {
                        var errorForStatus400 = _client.TryDeserialize<JsonDocument>(responseBody);
                        throw new ApiException<JsonDocument>(response.StatusCode, errorForStatus400, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<CheckoutSuccess>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<CheckoutSuccess>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }
}