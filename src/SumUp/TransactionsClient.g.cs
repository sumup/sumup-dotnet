// <auto-generated />
#nullable enable

namespace SumUp;

using System;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using SumUp.Http;

public sealed partial class TransactionsClient
{
    private readonly ApiClient _client;

    internal TransactionsClient(ApiClient client)
    {
        _client = client;
    }

    /// <summary>
    /// Retrieve a transaction
    /// </summary>
    /// <remarks>Retrieves the full details of an identified transaction. The transaction resource is identified by a query parameter and *one* of following parameters is required: * `id` * `internal_id` * `transaction_code` * `foreign_transaction_id` * `client_transaction_id`</remarks>
    /// <param name="merchantCode">Request parameter.</param>
    /// <param name="id">Retrieves the transaction resource with the specified transaction ID (the `id` parameter in the transaction resource).</param>
    /// <param name="internalId">Retrieves the transaction resource with the specified internal transaction ID (the `internal_id` parameter in the transaction resource).</param>
    /// <param name="transactionCode">Retrieves the transaction resource with the specified transaction code.</param>
    /// <param name="foreignTransactionId">External/foreign transaction id (passed by clients).</param>
    /// <param name="clientTransactionId">Client transaction id.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<TransactionFull> Get(string merchantCode, string? id = null, string? internalId = null, string? transactionCode = null, string? foreignTransactionId = null, string? clientTransactionId = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v2.1/merchants/{merchant_code}/transactions", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("id", id);
            builder.AddQuery("internal_id", internalId);
            builder.AddQuery("transaction_code", transactionCode);
            builder.AddQuery("foreign_transaction_id", foreignTransactionId);
            builder.AddQuery("client_transaction_id", clientTransactionId);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<TransactionFull>(stream, _client.SerializerOptions);
            return ApiResponse<TransactionFull>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a transaction
    /// </summary>
    /// <remarks>Retrieves the full details of an identified transaction. The transaction resource is identified by a query parameter and *one* of following parameters is required: * `id` * `internal_id` * `transaction_code` * `foreign_transaction_id` * `client_transaction_id`</remarks>
    /// <param name="merchantCode">Request parameter.</param>
    /// <param name="id">Retrieves the transaction resource with the specified transaction ID (the `id` parameter in the transaction resource).</param>
    /// <param name="internalId">Retrieves the transaction resource with the specified internal transaction ID (the `internal_id` parameter in the transaction resource).</param>
    /// <param name="transactionCode">Retrieves the transaction resource with the specified transaction code.</param>
    /// <param name="foreignTransactionId">External/foreign transaction id (passed by clients).</param>
    /// <param name="clientTransactionId">Client transaction id.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<TransactionFull>> GetAsync(string merchantCode, string? id = null, string? internalId = null, string? transactionCode = null, string? foreignTransactionId = null, string? clientTransactionId = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v2.1/merchants/{merchant_code}/transactions", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("id", id);
            builder.AddQuery("internal_id", internalId);
            builder.AddQuery("transaction_code", transactionCode);
            builder.AddQuery("foreign_transaction_id", foreignTransactionId);
            builder.AddQuery("client_transaction_id", clientTransactionId);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<TransactionFull>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<TransactionFull>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a transaction
    /// </summary>
    /// <remarks>Retrieves the full details of an identified transaction. The transaction resource is identified by a query parameter and *one* of following parameters is required: * `id` * `internal_id` * `transaction_code` * `foreign_transaction_id` * `client_transaction_id`</remarks>
    /// <param name="id">Retrieves the transaction resource with the specified transaction ID (the `id` parameter in the transaction resource).</param>
    /// <param name="internalId">Retrieves the transaction resource with the specified internal transaction ID (the `internal_id` parameter in the transaction resource).</param>
    /// <param name="transactionCode">Retrieves the transaction resource with the specified transaction code.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<TransactionFull> GetDeprecated(string? id = null, string? internalId = null, string? transactionCode = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/me/transactions", builder =>
        {
            builder.AddQuery("id", id);
            builder.AddQuery("internal_id", internalId);
            builder.AddQuery("transaction_code", transactionCode);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<TransactionFull>(stream, _client.SerializerOptions);
            return ApiResponse<TransactionFull>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Retrieve a transaction
    /// </summary>
    /// <remarks>Retrieves the full details of an identified transaction. The transaction resource is identified by a query parameter and *one* of following parameters is required: * `id` * `internal_id` * `transaction_code` * `foreign_transaction_id` * `client_transaction_id`</remarks>
    /// <param name="id">Retrieves the transaction resource with the specified transaction ID (the `id` parameter in the transaction resource).</param>
    /// <param name="internalId">Retrieves the transaction resource with the specified internal transaction ID (the `internal_id` parameter in the transaction resource).</param>
    /// <param name="transactionCode">Retrieves the transaction resource with the specified transaction code.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<TransactionFull>> GetDeprecatedAsync(string? id = null, string? internalId = null, string? transactionCode = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/me/transactions", builder =>
        {
            builder.AddQuery("id", id);
            builder.AddQuery("internal_id", internalId);
            builder.AddQuery("transaction_code", transactionCode);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<TransactionFull>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<TransactionFull>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List transactions
    /// </summary>
    /// <remarks>Lists detailed history of all transactions associated with the merchant profile.</remarks>
    /// <param name="merchantCode">Request parameter.</param>
    /// <param name="transactionCode">Retrieves the transaction resource with the specified transaction code.</param>
    /// <param name="order">Specifies the order in which the returned results are displayed.</param>
    /// <param name="limit">Specifies the maximum number of results per page. Value must be a positive integer and if not specified, will return 10 results.</param>
    /// <param name="users">Filters the returned results by user email.</param>
    /// <param name="statuses">Filters the returned results by the specified list of final statuses of the transactions.</param>
    /// <param name="paymentTypes">Filters the returned results by the specified list of payment types used for the transactions.</param>
    /// <param name="entryModes">Filters the returned results by the specified list of entry modes.</param>
    /// <param name="types">Filters the returned results by the specified list of transaction types.</param>
    /// <param name="changesSince">Filters the results by the latest modification time of resources and returns only transactions that are modified *at or after* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="newestTime">Filters the results by the creation time of resources and returns only transactions that are created *before* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="newestRef">Filters the results by the reference ID of transaction events and returns only transactions with events whose IDs are *smaller* than the specified value. This parameters supersedes the `newest_time` parameter (if both are provided in the request).</param>
    /// <param name="oldestTime">Filters the results by the creation time of resources and returns only transactions that are created *at or after* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="oldestRef">Filters the results by the reference ID of transaction events and returns only transactions with events whose IDs are *greater* than the specified value. This parameters supersedes the `oldest_time` parameter (if both are provided in the request).</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<TransactionsListResponse> List(string merchantCode, string? transactionCode = null, string? order = null, int? limit = null, IEnumerable<string>? users = null, IEnumerable<string>? statuses = null, IEnumerable<PaymentType>? paymentTypes = null, IEnumerable<EntryModeFilter>? entryModes = null, IEnumerable<string>? types = null, DateTimeOffset? changesSince = null, DateTimeOffset? newestTime = null, string? newestRef = null, DateTimeOffset? oldestTime = null, string? oldestRef = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v2.1/merchants/{merchant_code}/transactions/history", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("transaction_code", transactionCode);
            builder.AddQuery("order", order);
            builder.AddQuery("limit", limit);
            builder.AddQuery("users", users);
            builder.AddQuery("statuses", statuses);
            builder.AddQuery("payment_types", paymentTypes);
            builder.AddQuery("entry_modes[]", entryModes);
            builder.AddQuery("types", types);
            builder.AddQuery("changes_since", changesSince);
            builder.AddQuery("newest_time", newestTime);
            builder.AddQuery("newest_ref", newestRef);
            builder.AddQuery("oldest_time", oldestTime);
            builder.AddQuery("oldest_ref", oldestRef);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<TransactionsListResponse>(stream, _client.SerializerOptions);
            return ApiResponse<TransactionsListResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List transactions
    /// </summary>
    /// <remarks>Lists detailed history of all transactions associated with the merchant profile.</remarks>
    /// <param name="merchantCode">Request parameter.</param>
    /// <param name="transactionCode">Retrieves the transaction resource with the specified transaction code.</param>
    /// <param name="order">Specifies the order in which the returned results are displayed.</param>
    /// <param name="limit">Specifies the maximum number of results per page. Value must be a positive integer and if not specified, will return 10 results.</param>
    /// <param name="users">Filters the returned results by user email.</param>
    /// <param name="statuses">Filters the returned results by the specified list of final statuses of the transactions.</param>
    /// <param name="paymentTypes">Filters the returned results by the specified list of payment types used for the transactions.</param>
    /// <param name="entryModes">Filters the returned results by the specified list of entry modes.</param>
    /// <param name="types">Filters the returned results by the specified list of transaction types.</param>
    /// <param name="changesSince">Filters the results by the latest modification time of resources and returns only transactions that are modified *at or after* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="newestTime">Filters the results by the creation time of resources and returns only transactions that are created *before* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="newestRef">Filters the results by the reference ID of transaction events and returns only transactions with events whose IDs are *smaller* than the specified value. This parameters supersedes the `newest_time` parameter (if both are provided in the request).</param>
    /// <param name="oldestTime">Filters the results by the creation time of resources and returns only transactions that are created *at or after* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="oldestRef">Filters the results by the reference ID of transaction events and returns only transactions with events whose IDs are *greater* than the specified value. This parameters supersedes the `oldest_time` parameter (if both are provided in the request).</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<TransactionsListResponse>> ListAsync(string merchantCode, string? transactionCode = null, string? order = null, int? limit = null, IEnumerable<string>? users = null, IEnumerable<string>? statuses = null, IEnumerable<PaymentType>? paymentTypes = null, IEnumerable<EntryModeFilter>? entryModes = null, IEnumerable<string>? types = null, DateTimeOffset? changesSince = null, DateTimeOffset? newestTime = null, string? newestRef = null, DateTimeOffset? oldestTime = null, string? oldestRef = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v2.1/merchants/{merchant_code}/transactions/history", builder =>
        {
            builder.AddPath("merchant_code", merchantCode);
            builder.AddQuery("transaction_code", transactionCode);
            builder.AddQuery("order", order);
            builder.AddQuery("limit", limit);
            builder.AddQuery("users", users);
            builder.AddQuery("statuses", statuses);
            builder.AddQuery("payment_types", paymentTypes);
            builder.AddQuery("entry_modes[]", entryModes);
            builder.AddQuery("types", types);
            builder.AddQuery("changes_since", changesSince);
            builder.AddQuery("newest_time", newestTime);
            builder.AddQuery("newest_ref", newestRef);
            builder.AddQuery("oldest_time", oldestTime);
            builder.AddQuery("oldest_ref", oldestRef);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<TransactionsListResponse>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<TransactionsListResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List transactions
    /// </summary>
    /// <remarks>Lists detailed history of all transactions associated with the merchant profile.</remarks>
    /// <param name="transactionCode">Retrieves the transaction resource with the specified transaction code.</param>
    /// <param name="order">Specifies the order in which the returned results are displayed.</param>
    /// <param name="limit">Specifies the maximum number of results per page. Value must be a positive integer and if not specified, will return 10 results.</param>
    /// <param name="users">Filters the returned results by user email.</param>
    /// <param name="statuses">Filters the returned results by the specified list of final statuses of the transactions.</param>
    /// <param name="paymentTypes">Filters the returned results by the specified list of payment types used for the transactions.</param>
    /// <param name="types">Filters the returned results by the specified list of transaction types.</param>
    /// <param name="changesSince">Filters the results by the latest modification time of resources and returns only transactions that are modified *at or after* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="newestTime">Filters the results by the creation time of resources and returns only transactions that are created *before* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="newestRef">Filters the results by the reference ID of transaction events and returns only transactions with events whose IDs are *smaller* than the specified value. This parameters supersedes the `newest_time` parameter (if both are provided in the request).</param>
    /// <param name="oldestTime">Filters the results by the creation time of resources and returns only transactions that are created *at or after* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="oldestRef">Filters the results by the reference ID of transaction events and returns only transactions with events whose IDs are *greater* than the specified value. This parameters supersedes the `oldest_time` parameter (if both are provided in the request).</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<TransactionsListDeprecatedResponse> ListDeprecated(string? transactionCode = null, string? order = null, int? limit = null, IEnumerable<string>? users = null, IEnumerable<string>? statuses = null, IEnumerable<PaymentType>? paymentTypes = null, IEnumerable<string>? types = null, DateTimeOffset? changesSince = null, DateTimeOffset? newestTime = null, string? newestRef = null, DateTimeOffset? oldestTime = null, string? oldestRef = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/me/transactions/history", builder =>
        {
            builder.AddQuery("transaction_code", transactionCode);
            builder.AddQuery("order", order);
            builder.AddQuery("limit", limit);
            builder.AddQuery("users", users);
            builder.AddQuery("statuses", statuses);
            builder.AddQuery("payment_types", paymentTypes);
            builder.AddQuery("types", types);
            builder.AddQuery("changes_since", changesSince);
            builder.AddQuery("newest_time", newestTime);
            builder.AddQuery("newest_ref", newestRef);
            builder.AddQuery("oldest_time", oldestTime);
            builder.AddQuery("oldest_ref", oldestRef);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).GetAwaiter().GetResult();
            var result = JsonSerializer.Deserialize<TransactionsListDeprecatedResponse>(stream, _client.SerializerOptions);
            return ApiResponse<TransactionsListDeprecatedResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// List transactions
    /// </summary>
    /// <remarks>Lists detailed history of all transactions associated with the merchant profile.</remarks>
    /// <param name="transactionCode">Retrieves the transaction resource with the specified transaction code.</param>
    /// <param name="order">Specifies the order in which the returned results are displayed.</param>
    /// <param name="limit">Specifies the maximum number of results per page. Value must be a positive integer and if not specified, will return 10 results.</param>
    /// <param name="users">Filters the returned results by user email.</param>
    /// <param name="statuses">Filters the returned results by the specified list of final statuses of the transactions.</param>
    /// <param name="paymentTypes">Filters the returned results by the specified list of payment types used for the transactions.</param>
    /// <param name="types">Filters the returned results by the specified list of transaction types.</param>
    /// <param name="changesSince">Filters the results by the latest modification time of resources and returns only transactions that are modified *at or after* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="newestTime">Filters the results by the creation time of resources and returns only transactions that are created *before* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="newestRef">Filters the results by the reference ID of transaction events and returns only transactions with events whose IDs are *smaller* than the specified value. This parameters supersedes the `newest_time` parameter (if both are provided in the request).</param>
    /// <param name="oldestTime">Filters the results by the creation time of resources and returns only transactions that are created *at or after* the specified timestamp (in [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) format).</param>
    /// <param name="oldestRef">Filters the results by the reference ID of transaction events and returns only transactions with events whose IDs are *greater* than the specified value. This parameters supersedes the `oldest_time` parameter (if both are provided in the request).</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<TransactionsListDeprecatedResponse>> ListDeprecatedAsync(string? transactionCode = null, string? order = null, int? limit = null, IEnumerable<string>? users = null, IEnumerable<string>? statuses = null, IEnumerable<PaymentType>? paymentTypes = null, IEnumerable<string>? types = null, DateTimeOffset? changesSince = null, DateTimeOffset? newestTime = null, string? newestRef = null, DateTimeOffset? oldestTime = null, string? oldestRef = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Get, "/v0.1/me/transactions/history", builder =>
        {
            builder.AddQuery("transaction_code", transactionCode);
            builder.AddQuery("order", order);
            builder.AddQuery("limit", limit);
            builder.AddQuery("users", users);
            builder.AddQuery("statuses", statuses);
            builder.AddQuery("payment_types", paymentTypes);
            builder.AddQuery("types", types);
            builder.AddQuery("changes_since", changesSince);
            builder.AddQuery("newest_time", newestTime);
            builder.AddQuery("newest_ref", newestRef);
            builder.AddQuery("oldest_time", oldestTime);
            builder.AddQuery("oldest_ref", oldestRef);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 401:
                    {
                        var errorForStatus401 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus401, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            using var stream = await ApiClient.ReadContentAsStreamAsync(response.Content!, effectiveCancellationToken).ConfigureAwait(false);
            var result = await JsonSerializer.DeserializeAsync<TransactionsListDeprecatedResponse>(stream, _client.SerializerOptions, effectiveCancellationToken).ConfigureAwait(false);
            return ApiResponse<TransactionsListDeprecatedResponse>.From(result, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Refund a transaction
    /// </summary>
    /// <remarks>Refunds an identified transaction either in full or partially.</remarks>
    /// <param name="txnId">Unique ID of the transaction.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public ApiResponse<JsonDocument> Refund(string txnId, TransactionsRefundRequest? body = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/me/refund/{txn_id}", builder =>
        {
            builder.AddPath("txn_id", txnId);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).GetAwaiter().GetResult();
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).GetAwaiter().GetResult();

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).GetAwaiter().GetResult();
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            return ApiResponse<JsonDocument>.From(default, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }

    /// <summary>
    /// Refund a transaction
    /// </summary>
    /// <remarks>Refunds an identified transaction either in full or partially.</remarks>
    /// <param name="txnId">Unique ID of the transaction.</param>
    /// <param name="body">Request body payload.</param>
    /// <param name="requestOptions">Optional per-request overrides.</param>
    /// <param name="cancellationToken">Token used to cancel the request.</param>
    public async Task<ApiResponse<JsonDocument>> RefundAsync(string txnId, TransactionsRefundRequest? body = null, RequestOptions? requestOptions = null, CancellationToken cancellationToken = default)
    {
        var request = _client.CreateRequest(HttpMethod.Post, "/v0.1/me/refund/{txn_id}", builder =>
        {
            builder.AddPath("txn_id", txnId);
        });
        var effectiveCancellationToken = ApiClient.CreateCancellationToken(cancellationToken, requestOptions, out var timeoutScope);
        try
        {
            await _client.ApplyAuthorizationHeaderAsync(request, effectiveCancellationToken, requestOptions).ConfigureAwait(false);
            if (body is not null && request.Content is null)
            {
                request.Content = _client.CreateContent(body, "application/json");
            }

            using var response = await _client.HttpClient.SendAsync(
                request,
                HttpCompletionOption.ResponseHeadersRead,
                effectiveCancellationToken).ConfigureAwait(false);

            if (!response.IsSuccessStatusCode)
            {
                var responseBody = response.Content is null
                    ? null
                    : await ApiClient.ReadContentAsStringAsync(response.Content, effectiveCancellationToken).ConfigureAwait(false);
                switch ((int)response.StatusCode)
                {
                    case 404:
                    {
                        var errorForStatus404 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus404, responseBody, response.RequestMessage?.RequestUri);
                    }
                    case 409:
                    {
                        var errorForStatus409 = _client.TryDeserialize<Error>(responseBody);
                        throw new ApiException<Error>(response.StatusCode, errorForStatus409, responseBody, response.RequestMessage?.RequestUri);
                    }
                }
                var fallbackError = _client.TryDeserialize<ApiError>(responseBody);
                throw new ApiException(response.StatusCode, fallbackError, responseBody, response.RequestMessage?.RequestUri);
            }
            return ApiResponse<JsonDocument>.From(default, response.StatusCode, response.Headers, response.RequestMessage?.RequestUri);
        }
        finally
        {
            timeoutScope?.Dispose();
        }
    }
}